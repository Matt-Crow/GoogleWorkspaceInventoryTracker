// This file has been generated by catgs.py
// glob of email
/**
 * This module is responsible for providing details on the emails this
 * application sends, without binding it to implementation details
 */
class Email {
    constructor(to=[], subject="", bodyHtml=""){
        if(!Array.isArray(to)){
            to = [to];
        }
        this.to = to;
        this.subject = subject;
        this.bodyHtml = bodyHtml;
    }
}
class EmailService {
    /**
     * @param {UserService} userService used to get lists of users who want
     *  each email type.
     * @param {(email)=>any} sendEmail sends emails
     * @param {Settings} settings contains email settings
     * @param {()=>null} regenerateInventoryForm regenerates the inventory
     *  form if it is stale.
     */
    constructor(userService, sendEmail, settings, regenerateInventoryForm){
        this._users = userService;
        this._sendEmail = sendEmail;
        this._settings = settings;
        this._regenerateInventoryForm = regenerateInventoryForm;
    }
    sendInventoryForm(){
        if(this._settings.isInventoryFormStale()){
            this._regenerateInventoryForm();
        }
        const to = this._users.getInventoryFormEmails();
        if(to.length === 0){
            return;
        }
        const newProdUrl = this._settings.getNewItemFormUrl();
        const removeItemUrl = this._settings.getRemoveItemFormUrl();
        const inventoryUrl = this._settings.getInventoryFormUrl();
        const sheetUrl = this._settings.getWorkbookUrl();
        const userUrl = this._settings.getUserFormUrl();
        const lines = [
            "This email was generated by the Google Workspace Inventory Tracker.",
            `This form adds a new item to your inventory: ${newProdUrl}.`,
            `This form removes an item from your inventory: ${removeItemUrl}`,
            `This form updates the items already recorded in your inventory: ${inventoryUrl}`,
            `You can view your inventory here: ${sheetUrl}`,
            `You can change your notification preferences here: ${userUrl}`
        ];
        const email = new Email(
            to,
            "It's time to update our inventory!",
            lines.map(line => `<p>${line}</p>`).join("\n")
        );
        this._sendEmail(email);
    }
    sendInventoryFormReply(){
        const to = this._users.where(u => u.wantsLogReply);
        if(to.length === 0){
            return;
        }
        const sheetUrl = this._settings.getWorkbookUrl();
        const userUrl = this._settings.getUserFormUrl();
        const lines = [
            "This email was generated by the Google Workspace Inventory Tracker.",
            "Your inventory has been successfully updated!",
            `You can see the result of these changes here: ${sheetUrl}.`,
            `You can opt out of receiving this email here: ${userUrl}`
        ];
        const email = new Email(
            to,
            "Our inventory has been successfully updated!",
            lines.map(line => `<p>${line}</p>`).join("\n")
        );
        this._sendEmail(email);
    }
    /**
     * Sends an email to all restockers, notifying them that the given items
     * need to be restocked.
     *
     * @param {Item[]} items which need to be restocked
     */
    sendRestockReminder(items){
        const to = this._users.where(u => u.wantsReport);
        if(to.length === 0){
            return;
        }
        const sheetUrl = this._settings.getWorkbookUrl();
        const userUrl = this._settings.getUserFormUrl();
        let lines = [
            "This email was generated by the Google Workspace Inventory Tracker."
        ];
        if(items.length === 0){
            lines.push("No items in your inventory are running low on stock, yay!");
            lines = lines.map(line => `<p>${line}</p>`);
        } else {
            lines.push("The following items are running low on stock:");
            lines = lines.map(line => `<p>${line}</p>`);
            const itemLines = items.map(item => `${item.name} x ${item.quantity} (minimum is ${item.minimum})`);
            lines.push("<ul>");
            itemLines.map(line=>`<li>${line}</li>`).forEach(line=>lines.push(line));
            lines.push("</ul>");
        }
        lines.push(`<p>You view your inventory here: ${sheetUrl}</p>`);
        lines.push(`<p>You can opt out of receiving this email here: ${userUrl}</p>`);
        const email = new Email(
            to,
            "What we need to get",
            lines.join("\n")
        );
        this._sendEmail(email);
    }
}
function testEmailModule(){
    const sentEmails = new Map();
    const users = [
        new User("foo.bar@gmail.com", true, false),
        new User("baz.qux@gmail.com", false, false)
    ];
    const repo = makeInMemoryUserRepository(users);
    const userService = new UserService(repo);
    let settings = {};
    const emailRecorder = (email)=>{
        email.to.forEach(addr=>{
            if(!sentEmails.has(addr)){
                sentEmails.set(addr, []);
            }
            sentEmails.get(addr).push(email);
        });
    };
    const settingService = new Settings(
        k => settings[k],
        (k, v)=> {
            if(!settings[k]){
                settings[k] = new Setting(k, v);
            } else {
                settings[k].value = v;
            }
        },
        setting => settings[setting.name] = setting
    );
    settingService.populateDefaults();
    const emailService = new EmailService(
        userService,
        emailRecorder,
        settingService,
        ()=>settingService.setInventoryFormStale(false)
    );
    emailService.sendInventoryForm();
    assert(sentEmails.has("foo.bar@gmail.com"));
    assert(1 === sentEmails.get("foo.bar@gmail.com").length);
    assert(!sentEmails.has("baz.qux@gmail.com"));
}
// glob of item
/**
 * This module is responsible for services related to Items
 *
 * Data class: Item
 * #----------#--------#
 * |     name | string |
 * | quantity | int    |
 * |  minimum | int    |
 * #----------#--------#
 */
/**
 * the Item class represents something that can be tracked by the system
 */
class Item {
    /**
     * @param {string} name - an identifier for this type of item
     * @param {number} quantity - the amount of this item currently in stock
     * @param {number} minimum - the system will report when quantity <= minimum
     */
    constructor(name, quantity=0, minimum=0){
        mustHaveValue(name);
        mustHaveValue(quantity);
        mustBeNonNegative(quantity);
        mustHaveValue(minimum);
        mustBeNonNegative(minimum);
        this.name = normalizeItemName(name);
        this.quantity = quantity;
        this.minimum = minimum;
    }
    dataEquals(other){
        return this.name === other.name &&
            this.quantity === other.quantity &&
            this.minimum === other.minimum;
    }
    copy(){
        return new Item(this.name, this.quantity, this.minimum);
    }
}
/**
 * Items are considered equal if their names are the same, ignoring case
 *
 * @param {string} name
 * @returns the normalized item name
 */
function normalizeItemName(name){
    return name.toLowerCase();
}
function makeInMemoryItemRepository(entities=[]){
    const repo = new InMemoryRepository(
        item => item.name,
        name => normalizeItemName(name),
        item => item.copy()
    );
    entities.forEach(e => repo.addEntity(e));
    return repo;
}
/**
 * The ItemService handles Items business logic
 */
class ItemService {
    /**
     * @param {Repository} repository stores the Items this interacts
     *  with.
     * @param {EmailService} emails sends emails upon receiving this inventory
     *  form.
     */
    constructor(repository, emails){
        this.repository = repository;
        this._emails = emails;
    }
    /**
     * @returns {Item[]}
     */
    getAllEntities(){
        return this.repository.getAllEntities();
    }
    /**
     * @returns {Item[]} the items that are at or below their minimum quantities
     */
    getItemsToRestock(){
        return this.repository
            .getAllEntities()
            .filter(item => item.quantity <= item.minimum)
            .map(item => item.copy());
    }
    /**
     * @param {Item} item
     */
    handleNewItem(item){
        if(this.repository.hasEntityWithKey(item.name)){
            this.repository.update(item);
        } else {
            this.repository.addEntity(item);
        }
        this._emails.sendInventoryFormReply();
    }
    /**
     * @param {Item[]} changes
     */
    handleLogForm(changes){
        /*
        the items created by the log form have no "minimum" field, so need to
        retrieve that field from the current repository
        */
        const oldItems = this.repository.getAllEntities();
        const nameToItem = new Map();
        oldItems.forEach(item=>nameToItem.set(item.name, item));
        changes.forEach(change=>{
            if(!nameToItem.has(change.name)){
                console.error(`Log form contains new item: ${change.name}. Maybe regenerate the inventory form?`);
            }
            nameToItem.get(change.name).quantity = change.quantity;
        });
        for(const changedItem of nameToItem.values()){
            this.repository.update(changedItem);
        }
        this._emails.sendInventoryFormReply();
    }
    /**
     * Removes an item with the given name from the backing store. It is not an
     * error to attempt to remove an item that does not exist, so this operation
     * is idempotent.
     *
     * @param {string} itemName the name of item to remove
     */
    remove(itemName) {
        this.repository.deleteEntityWithKey(itemName);
    }
}
/**
 * runs all unit tests for this module, throwing an exception if any fail
 */
function testItemModule(){
    testItem();
    testInMemoryItemRepository();
    testItemService();
    testGetItemsToRestock();
    testRemoveItems();
}
function testItem(){
    // any defined name is OK
    const name = "foo";
    new Item(name);
    assertThrows(()=>new Item(undefined));
    assertThrows(()=>new Item(null));
    // amount must be defined and non-negative
    const amount = 5;
    new Item(name, amount);
    new Item(name, 0);
    assertThrows(()=>new Item(name, null));
    assertThrows(()=>new Item(name, -amount));
    // minimum must be defined and non-negative
    const minimum = 3;
    new Item(name, amount, minimum);
    new Item(name, amount, 0);
    assertThrows(()=>new Item(name, amount, null));
    assertThrows(()=>new Item(name, amount, -minimum));
}
function testInMemoryItemRepository(){
    const data = new Item("foo");
    const itemComparator = (a, b) => a.dataEquals(b);
    let sut = makeInMemoryItemRepository();
    sut.addEntity(data);
    assertContains(data, sut._entities.values(), itemComparator);
    sut = makeInMemoryItemRepository([data]);
    let actual = sut.getEntityByKey(data.name);
    assert(data.dataEquals(actual));
    const values = ["foo", "bar", "baz"].map(n => new Item(n));
    sut = makeInMemoryItemRepository(values);
    actual = sut.getAllEntities();
    assert(3 === actual.length);
    assertContains(values[0], actual, itemComparator);
    assertContains(values[1], actual, itemComparator);
    assertContains(values[2], actual, itemComparator);
    sut = makeInMemoryItemRepository([data]);
    let changed = data.copy();
    changed.quantity += 1;
    sut.update(changed);
    actual = sut.getEntityByKey(data.name);
    assert(changed.dataEquals(actual));
    assert(!data.dataEquals(actual));
}
function testItemService(){
    const itemComparator = (a, b) => a.dataEquals(b);
    const exists = new Item("foo");
    const repo = makeInMemoryItemRepository([exists]);
    const emails = {
        sendInventoryFormReply: ()=>null
    };
    const sut = new ItemService(repo, emails);
    const expected = [
        exists.copy()
    ];
    expected[0].quantity += 1;
    sut.handleLogForm(expected);
    const actual = repo.getAllEntities();
    assert(expected.length === actual.length);
    assertContains(expected[0], actual, itemComparator);
    assertDoesNotContain(exists, actual, itemComparator);
}
function testGetItemsToRestock(){
    const itemComparator = (a, b) => a.dataEquals(b);
    const expected = new Item("foo", 3, 4);
    const minimumEqualQuantity = new Item("bar", 3, 3);
    const notExpected = new Item("baz", 4, 3);
    const repo = makeInMemoryItemRepository([
        expected,
        minimumEqualQuantity,
        notExpected
    ]);
    const sut = new ItemService(repo, {});
    const actual = sut.getItemsToRestock();
    assertContains(expected, actual, itemComparator);
    assertContains(minimumEqualQuantity, actual, itemComparator);
    assertDoesNotContain(notExpected, actual, itemComparator);
}
function testRemoveItems() {
    const itemComparator = (a, b) => a.name === b.name;
    const removeMe = new Item("foo");
    const keepMe = new Item("bar");
    const repo = makeInMemoryItemRepository([removeMe, keepMe]);
    const sut = new ItemService(repo, {});
    sut.remove(removeMe.name);
    sut.remove("baz");
    sut.remove("qux");
    const remaining = sut.getAllEntities();
    assertContains(keepMe, remaining, itemComparator);
    assertDoesNotContain(removeMe, remaining, itemComparator);
}
// glob of orm
// maybe try to abstractify this into both inmemory and gsrepo
class Repository {
    constructor(){
    }
    addEntity(entity){
    }
    hasEntityWithKey(key){
    }
    deleteEntityWithKey(key) {
    }
}
/**
 * stores entities in memory
 */
class InMemoryRepository {
    /**
     *
     * @param {(e: TEntity)=>TKey} getKey maps entities to their primary key
     * @param {(key: TKey)=>TKey} formatKey for example, uppercasing names
     * @param {(e: TEntity)=>TEntity} copy used to copy entities for storage.
     *  Can return e to store argument.
     */
    constructor(getKey, formatKey, copy){
        this._entities = new Map();
        this._getKey = getKey;
        this._formatKey = formatKey;
        this._copy = copy;
    }
    addEntity(entity){
        const key = this._formatKey(this._getKey(entity));
        if(this.hasEntityWithKey(key)){
            throw new Error(`Duplicate key: ${key}`);
        }
        this._entities.set(key, this._copy(entity));
    }
    hasEntityWithKey(key){
        return this._entities.has(this._formatKey(key));
    }
    getEntityByKey(key){
        key = this._formatKey(key);
        if(!this.hasEntityWithKey(key)){
            throw new Error(`No entity with key: ${key}`);
        }
        return this._copy(this._entities.get(key));
    }
    getAllEntities(){
        return Array.from(this._entities.values()).map(e => this._copy(e));
    }
    update(entity){
        const key = this._formatKey(this._getKey(entity));
        if(!this.hasEntityWithKey(key)){
            throw new Error(`No entity with key, so cannot update: ${key}`);
        }
        this._entities.set(key, this._copy(entity));
    }
    deleteEntityWithKey(key) {
        const formattedKey = this._formatKey(key);
        if (this.hasEntityWithKey(formattedKey)) {
            this._entities.delete(formattedKey);
        }
    }
}
/**
 * stores entities in a Google sheet
 */
class GoogleSheetsRepository {
    /**
     * @param {SpreadsheetApp.Spreadsheet} sheet stores entities
     * @param {(TEntity)=>TKey} getKey extracts the primary key for an entity
     * @param {(TEntity)=>any[]} toRow converts an entity to a sheet row. The primary key must go in the first column
     * @param {(any[])=>TEntity} toEntity converts a row to an entity
     */
    constructor(sheet, getKey, toRow, toEntity){
        this._sheet = sheet;
        this._getKey = getKey;
        this._toRow = toRow;
        this._toEntity = toEntity;
    }
    addEntity(entity){
        const key = this.formatKey(this._getKey(entity));
        if(this.hasEntityWithKey(key)){
            throw new Error(`Duplicate key: ${key}`);
        }
        this._sheet.appendRow(this._toRow(entity));
    }
    formatKey(key) {
        return key.toLowerCase();
    }
    hasEntityWithKey(key){
        return this._getAllKeys().includes(this.formatKey(key));
    }
    /**
     * @returns {string[]} all the keys in the sheet, sorted by row
     */
    _getAllKeys() {
        return this._sheet
            .getRange("A2:A")
            .getValues()
            .map(row=>row[0])
            .map(cell=>this.formatKey(cell));
    }
    getEntityByKey(key){
        key = this.formatKey(key);
        if(!this.hasEntityWithKey(key)){
            throw new Error(`No entity with key: ${key}`);
        }
        const rows = this._sheet.getDataRange().getValues();
        rows.shift(); // remove header
        const idx = rows.findIndex(row => this.formatKey(row[0]) === key);
        return this._toEntity(rows[idx]);
    }
    getAllEntities(){
        const rows = this._sheet.getDataRange().getValues();
        rows.shift();
        return rows.map(row=>this._toEntity(row));
    }
    update(entity){
        const key = this.formatKey(this._getKey(entity));
        if(!this.hasEntityWithKey(key)){
            throw new Error(`No entity with key, so cannot update: ${key}`);
        }
        const rows = this._sheet.getDataRange().getValues();
        rows.shift();
        const idx = rows.findIndex(row=>this.formatKey(row[0]) === key);
        const newRow = this._toRow(entity);
        //                      translate from 0 to 1 idx, +1 for header
        this._sheet.getRange(idx + 2, 1, 1, newRow.length).setValues([newRow]);
    }
    deleteEntityWithKey(key) {
        key = this.formatKey(key);
        const arrayIdx = this._getAllKeys().findIndex((element) => this.formatKey(element) === key);
        if (arrayIdx != -1) { // entity with that key exists
            // +1 since deleteRow is 1-indexed, +1 again for header
            const rowIdx = arrayIdx + 2;
            this._sheet.deleteRow(rowIdx);
        }
    }
}
// glob of reminders
/**
 * Code related to scheduling and managing automated reminders
 */
/**
 * A reminder is a function that should be called by an executor according to a
 * specific interval, such as every 7 days.
 */
class Reminder {
    /**
     * @param {String} name a name for this reminder
     * @param {()=>any} fn a function which accepts no arguments
     * @param {int} interval the interval, in days, between executions
     */
    constructor(name, fn, interval){
        this.name = name;
        this.fn = fn;
        this.interval = interval;
        this.wasCreated = false;
    }
    created() {
        this.wasCreated = true;
    }
}
/**
 * Handles creating & deleting reminders
 */
class ReminderService {
    /**
     * @param {Settings} settings the application settings
     * @param {(Reminder)=>any} createReminder registers the given reminder with
     *  an executor
     * @param {(Reminder)=>any} deleteReminder unregisters the given reminder
     *  with an executor
     */
    constructor(settings, createReminder, deleteReminder){
        this._settings = settings;
        this._createReminder = createReminder;
        this._deleteReminder = deleteReminder;
    }
    scheduleInventoryForm(){
        const interval = this._settings.getInventoryFormInterval();
        const reminder = new Reminder("Inventory form", sendInventoryForm, interval);
        return this._scheduleReminder(reminder);
    }
    scheduleRestockReminder(){
        const interval = this._settings.getRestockReminderInterval();
        const reminder = new Reminder("Restock reminder", sendRestockReminder, interval);
        return this._scheduleReminder(reminder);
    }
    _scheduleReminder(reminder) {
        this._deleteReminder(reminder);
        if (!isNaN(parseInt(reminder.interval))) {
            this._createReminder(reminder);
            reminder.created();
        }
        return reminder;
    }
}
// glob of settings
/**
 * This module is responsible for the the settings system the program uses.
 * Settings are essentially key-value pairs with a description attached.
 */
const KEYS = {
    INVENTORY_FORM_INTERVAL: "Inventory form interval",
    INVENTORY_FORM_STALE: "Inventory form is stale",
    INVENTORY_FORM_URL: "Inventory form URL",
    RESTOCK_REMINDER_INTERVAL: "Restock reminder interval",
    NEW_ITEM_FORM_URL: "New item form URL",
    REMOVE_ITEM_FORM_URL: "Remove item form URL",
    USER_FORM_URL: "User form URL",
    WORKBOOK_URL: "Workbook URL"
};
class Settings {
    /**
     *
     * @param {(key: string)=>Setting} getter returns the Setting for the given
     *  key, or null if not set
     * @param {(key: string, value: any)=>any} setter assigns the given
     *  value to the given setting
     * @param {(setting: Setting)=>any} defineSetting defines a new setting
     */
    constructor(getter, setter, defineSetting){
        this._get = getter;
        this._set = setter;
        this._define = defineSetting;
    }
    populateDefaults(){
        DEFAULT_SETTINGS.forEach(setting=>this._define(setting));
    }
    get(key){
        return this._get(key).value;
    }
    set(key, value){
        this._set(key, value);
    }
    defineSetting(key, value, description=""){
        this._define(new Setting(key, value, description));
    }
    getInventoryFormInterval(){
        return this.get(KEYS.INVENTORY_FORM_INTERVAL);
    }
    getRestockReminderInterval() {
        return this.get(KEYS.RESTOCK_REMINDER_INTERVAL);
    }
    setInventoryFormStale(isStale){
        this.set(KEYS.INVENTORY_FORM_STALE, (isStale) ? "yes" : "no");
    }
    isInventoryFormStale(){
        return this.get(KEYS.INVENTORY_FORM_STALE) === "yes";
    }
    setUserForm(form){
        this.set(KEYS.USER_FORM_URL, form.getPublishedUrl());
    }
    getUserFormUrl(){
        return this.get(KEYS.USER_FORM_URL);
    }
    setInventoryForm(form){
        this.set(KEYS.INVENTORY_FORM_URL, form.getPublishedUrl());
    }
    getInventoryFormUrl(){
        return this.get(KEYS.INVENTORY_FORM_URL);
    }
    setNewItemForm(form){
        this.set(KEYS.NEW_ITEM_FORM_URL, form.getPublishedUrl());
    }
    getNewItemFormUrl(){
        return this.get(KEYS.NEW_ITEM_FORM_URL);
    }
    setRemoveItemForm(form) {
        this.set(KEYS.REMOVE_ITEM_FORM_URL, form.getPublishedUrl());
    }
    getRemoveItemFormUrl() {
        return this.get(KEYS.REMOVE_ITEM_FORM_URL);
    }
    setWorkbook(workbook){
        this.set(KEYS.WORKBOOK_URL, workbook.getUrl());
    }
    getWorkbookUrl(){
        return this.get(KEYS.WORKBOOK_URL);
    }
}
class Setting {
    constructor(name, value, description=""){
        this.name = name;
        this.value = value;
        this.description = description;
    }
}
const DEFAULT_SETTINGS = [
    new Setting(KEYS.INVENTORY_FORM_INTERVAL, 7, "The number of days between sendings of the inventory form"),
    new Setting(KEYS.RESTOCK_REMINDER_INTERVAL, 7, "The number of days between sendings of the restock reminder"),
    new Setting(KEYS.INVENTORY_FORM_STALE, "no", "'yes' when the system will regenerate the inventory form"),
    new Setting(KEYS.USER_FORM_URL, "", "Use this form to sign up for notifications or change your preferences"),
    new Setting(KEYS.INVENTORY_FORM_URL, "", "Use this form to update the inventory"),
    new Setting(KEYS.NEW_ITEM_FORM_URL, "", "Use this form to record a new item in the inventory"),
    new Setting(KEYS.REMOVE_ITEM_FORM_URL, "", "Use this form to remove an existing item from the inventory"),
    new Setting(KEYS.WORKBOOK_URL, "", "The URL of this workbook")
];
function testSettings(){
    const settings = new Map();
    const sut = new Settings(
        (key)=>settings.get(key),
        (key, value)=>settings.get(key).value = value,
        (setting)=>settings.set(setting.name, setting)
    );
    sut.populateDefaults();
    mustBeDefined(sut.get(KEYS.INVENTORY_FORM_INTERVAL));
}
// glob of user
/**
 * This module is responsible for services related to Users
 *
 * Data class: User
 * #---------------#---------#
 * |         email | string  |
 * |      wantsLog | boolean |
 * | wantsLogReply | boolean |
 * |   wantsReport | boolean |
 * #---------------#---------#
 *
 * Note that it is not an error for a user to want the log reply, yet not the
 * log, as that allows them to learn when others update the inventory.
 */
class User {
    /**
     *
     * @param {string} email
     * @param {boolean|undefined} wantsLog true if this user should receive
     *  the inventory form
     * @param {boolean|undefined} wantsLogReply the if this user should receive
     *  an email whenever someone submits the inventory form
     * @param {boolean|undefined} wantsReport true if this user should receive
     *  the restocking report email
     */
    constructor(email, wantsLog=false, wantsLogReply=false, wantsReport=false){
        mustHaveValue(email);
        this.email = email;
        this.wantsLog = !!wantsLog;
        this.wantsLogReply = !!wantsLogReply;
        this.wantsReport = !!wantsReport;
    }
    dataEquals(other){
        return this.email === other.email
            && this.wantsLog === other.wantsLog
            && this.wantsLogReply === other.wantsLogReply
            && this.wantsReport === other.wantsReport;
    }
    copy(){
        return new User(
            this.email,
            this.wantsLog,
            this.wantsLogReply,
            this.wantsReport
        );
    }
}
function makeInMemoryUserRepository(users=[]){
    const repo = new InMemoryRepository(
        u => u.email,
        email => email,
        u => u.copy()
    );
    users.forEach(u => repo.addEntity(u));
    return repo;
}
class UserService {
    constructor(repo){
        this.users = repo;
    }
    /**
     * @returns {string[]} the email addresses of users who want the inventory
     *  form
     */
    getInventoryFormEmails(){
        return this.where(u=>u.wantsLog);
    }
    where(predicate){
        return this.users.getAllEntities().filter(predicate).map(u=>u.email);
    }
    handleUserForm(user){
        if(this.users.hasEntityWithKey(user.email)){
            this.users.update(user);
        } else {
            this.users.addEntity(user);
        }
    }
}
function testUserModule(){
    const wantsLog = "baz.qux@gmail.com";
    const doesNotWantLog = "foo.bar@gmail.com";
    const users = [
        new User(doesNotWantLog),
        new User(wantsLog, true, true, true)
    ];
    const repo = makeInMemoryUserRepository(users);
    const sut = new UserService(repo);
    const actual = sut.getInventoryFormEmails();
    assertContains(wantsLog, actual);
    assertDoesNotContain(doesNotWantLog, actual);
}
// glob of utilities
/**
 * This module contains miscillaneous utilities.
 *
 * void assert(boolean, string?)
 * void assertThrows(void function())
 * void assertContains(T, T[], boolean function(T, T))
 * void assertDoesNotContain(T, T[], boolean function(T, T))
 *
 * void mustBeNonNegative(number)
 * void mustBeNumber(obj)
 * void mustBePositive(number)
 *
 * void mustBeDefined(*)
 * void mustHaveValue(*)
 */
function assert(bool, msg=""){
    if(!bool){
        throw new Error(msg);
    }
}
function assertThrows(fn){
    let anExceptionWasThrown = false;
    try {
        fn();
    } catch(ex){
        anExceptionWasThrown = true;
    }
    if(!anExceptionWasThrown){
        throw new Error("Function failed to throw an error");
    }
}
function assertContains(item, collection, comparator=(a, b)=>a===b){
    if(!Array.from(collection).some((curr)=>comparator(curr, item))){
        throw new Error(`${collection} does not contain ${item}`);
    }
}
function assertDoesNotContain(item, collection, comparator=(a, b)=>a===b){
    if(Array.from(collection).some((curr)=>comparator(curr, item))){
        throw new Error(`${collection} does contains ${item}`);
    }
}
function mustBePositive(num){
    mustBeNumber(num);
    if(num <= 0){
        throw new Error(`Value must be positive: ${num}`);
    }
}
function mustBeNumber(obj){
    const rightType = typeof(obj) === typeof(1);
    const isNum = rightType && !isNaN(obj);
    if(!isNum){
        throw new Error(`Value must be a number: ${obj}`);
    }
}
function mustBeNonNegative(num){
    mustBeNumber(num);
    if(num < 0){
        throw new Error(`Value must be non-negative: ${num}`);
    }
}
function mustBeDefined(obj){
    if(undefined === obj){
        throw new Error("Value cannot be undefined");
    }
}
function mustHaveValue(obj){
    mustBeDefined(obj)
    if(null === obj){
        throw new Error("Value cannot be null");
    }
}
// glob of gmail
/**
 * This module is responsible for implementing email.js using the Google Mail
 * App.
 *
 * https://developers.google.com/apps-script/reference/mail
 */
 function createEmailService(workspace=null){
    workspace = Workspace.currentOr(workspace);
    const users = createUserService(workspace);
    const emailSender = (email)=>MailApp.sendEmail({ // convert my model to the
        to: email.to.join(","),                      // one MailApp uses
        subject: email.subject,
        htmlBody: email.bodyHtml
    });
    const settings = createSettings(workspace);
    const regenForm = ()=>regenerateInventoryFormFor(workspace);
    return new EmailService(users, emailSender, settings, regenForm);
}
// glob of googleReminders
function createReminderService(workspace=null) {
    workspace = Workspace.currentOr(workspace);
    return new ReminderService(
        createSettings(workspace),
        _createGoogleReminder,
        _deleteGoogleReminder
    );
}
function _createGoogleReminder(reminder) {
    // ReminderService handles calling delete first
    ScriptApp.newTrigger(reminder.fn.name)
        .timeBased()
        .everyDays(reminder.interval)
        .create();
}
function _deleteGoogleReminder(reminder) {
    ScriptApp.getProjectTriggers()
        .filter(t => t.getHandlerFunction() === reminder.fn.name)
        .forEach(t => ScriptApp.deleteTrigger(t));
}
// glob of inventoryForm
/**
 * This module is responsible for the Google Form used to update the quantity of
 * each item currently in the inventory.
 */
/**
 * Use this to interface with the Inventory form component of the system.
 * @param {Workspace|undefined} workspace the workspace to get the component of
 * @returns the Inventory form component of the application
 */
function inventoryFormModule(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _inventoryFormNameFor,
        ()=>{
            const form = _createNewInventoryForm(workspace);
            createSettings(workspace).setInventoryForm(form);
            return form;
        },
        _onInventoryFormSubmit
    );
}
function _inventoryFormNameFor(namespace=""){
    return nameFor("Inventory form", namespace);
}
function _createNewInventoryForm(workspace){
    const form = FormApp.create(_inventoryFormNameFor(workspace.namespace));
    form.setDescription("How many of each of these are in the inventory now?");
    form.setCollectEmail(true);
    _populateInventoryForm(form, workspace);
    return form;
}
function _populateInventoryForm(form, workspace){
    const mustBeANonNegativeNumber = FormApp.createTextValidation()
        .setHelpText("Must be a non-negative number.")
        .requireNumberGreaterThanOrEqualTo(0)
        .build();
    const service = createItemService(workspace);
    const itemNames = service.getAllEntities().map(pt => pt.name);
    itemNames.forEach(itemName => {
        form.addTextItem()
            .setTitle(itemName)
            .setRequired(false)
            .setValidation(mustBeANonNegativeNumber);
    });
}
function _onInventoryFormSubmit(e){
    /*
    e.namedValues is formatted as
    {
        foo: ["answer to foo"],
        bar: ["answer to bar"]
    }
    From what I gather, the last value of the foo array is the response to foo.
    Previous indices are in case multiple questions have existed with the same
    name. These arrays will get longer each time the form regenerates.
    */
    const fields = [];
    for(let [k, v] of Object.entries(e.namedValues)){
        //                                       last item
        fields.push({name: k, quantity: parseInt(v.at(-1))});
    }
    const items = fields.filter(answerToQuestion => {
        return !isNaN(answerToQuestion.quantity);
    }).filter(answerToQuestion => {
        return "Timestamp" !== answerToQuestion.name;
    }).filter(answerToQuestion => {
        return "Email Address" !== answerToQuestion.name;
    }).map(answerToQuestion =>{
        return new Item(answerToQuestion.name, answerToQuestion.quantity);
    });
    const email = getEmailAddressFrom(e);
    console.log({
        event: `Received inventory form from ${email}`,
        items: items
    });
    createItemService().handleLogForm(items);
}
/**
 * Regenerates the inventory form by populating it with the current contents of
 * the inventory sheet.
 *
 * @param {Workspace} workspace the workspace to regenerate the inventory form
 *  for.
 */
function regenerateInventoryFormFor(workspace=null){
    workspace = Workspace.currentOr(workspace);
    const name = _inventoryFormNameFor(workspace.namespace);
    const sheet = workspace.workbook.getSheetByName(name);
    if(sheet === null){ // inventory form has not yet been generated
        inventoryFormModule(workspace).setup();
    } else {
        // remove all items, repopulate
        const formUrl = sheet.getFormUrl();
        const oldForm = FormApp.openByUrl(formUrl);
        oldForm.getItems().forEach(item=>oldForm.deleteItem(item));
        _populateInventoryForm(oldForm, workspace);
    }
    createSettings(workspace).setInventoryFormStale(false);
}
// glob of inventorySheet
/**
 * This module is responsible for the inventory sheet created by the application
 * in its host Google Spreadsheet.
 */
function inventorySheetModule(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _inventorySheetNameFor,
        ()=>_setupInventorySheet(workspace) // not just _setupInventorySheet
    );
}
function _inventorySheetNameFor(namespace){
    return nameFor("inventory", namespace);
}
function _setupInventorySheet(workspace){
    const name = _inventorySheetNameFor(workspace.namespace);
    const inventorySheet = workspace.workbook.insertSheet(name);
    inventorySheet.setFrozenRows(1);
    const validation = SpreadsheetApp.newDataValidation()
        .requireNumberGreaterThanOrEqualTo(0)
        .setAllowInvalid(false)
        .setHelpText("Quantity and minimum must both be a number at least 0")
        .build();
    const quantityAndMinimumColumns = inventorySheet.getRange("B2:C");
    quantityAndMinimumColumns.setDataValidation(validation);
    const headers = ["name", "quantity", "minimum"];
    inventorySheet.appendRow(headers);
}
/**
 * @param {Workspace|undefined} workspace
 * @returns {ItemService} an instance of ItemService backed by a Google sheet as
 *  its repository
 */
function createItemService(workspace=null){
    workspace = Workspace.currentOr(workspace);
    const name = _inventorySheetNameFor(workspace.namespace);
    const sheet = workspace.workbook.getSheetByName(name);
    const repo = makeGoogleSheetsItemRepository(sheet);
    const emails = createEmailService(workspace);
    const service = new ItemService(repo, emails);
    return service;
}
function makeGoogleSheetsItemRepository(sheet){
    return new GoogleSheetsRepository(
        sheet,
        (item)=>item.name,
        (item)=>[item.name, item.quantity, item.minimum],
        (row)=>new Item(
            row[0],
            (row[1] === "") ? undefined : row[1], // catch empty cells
            (row[2] === "") ? undefined : row[2]
        )
    );
}
function testGoogleSheetsItemRepository(workbook){
    const sheet = workbook.getSheetByName(_inventorySheetNameFor("test"));
    const sut = makeGoogleSheetsItemRepository(sheet)
    const expected = new Item("item");
    sut.addEntity(expected);
    assert(sut.hasEntityWithKey(expected.name));
    assert(!sut.hasEntityWithKey("not " + expected.name));
    const actual = sut.getEntityByKey(expected.name);
    assert(expected.dataEquals(actual));
    const all = sut.getAllEntities();
    assert(1 === all.length, `length should be 1, not ${all.length}`);
    assert(expected.dataEquals(all[0]));
}
// glob of main
/**
 * this module is responsible for loading interacting with the Google Sheets UI
 */
/**
 * called automatically upon opening the Google Spreadsheet
 */
function onOpen(){
	const ui = SpreadsheetApp.getUi();
	ui.createMenu("G-WIT")
		.addItem("Set up", setup.name)
		.addItem("Reset workspace", resetWorkspace.name)
		.addItem("Regenerate remove item form", regenerateRemoveItemFormFor.name)
		.addSubMenu(ui.createMenu("Inventory form")
			.addItem("Prime inventory form", primeInventoryForm.name)
			.addItem("Send inventory form", sendInventoryForm.name)
			.addItem("Regenerate inventory form", regenerateInventoryFormFor.name)
		)
		.addSubMenu(ui.createMenu("Restock reminder")
			.addItem("Prime restock reminder", primeRestockReminder.name)
			.addItem("Send restock reminder", sendRestockReminder.name)
		)
		.addSubMenu(ui.createMenu("Tests")
			.addItem("Run unit tests (fast)", unitTests.name)
			.addItem("Run integration tests (slow)", integrationTests.name)
		)
		.addToUi();
}
/**
 * mutates the current Google Sheet into a suitable environment for the program
 */
function setup(){
	setupWorkspace();
	SpreadsheetApp.getUi().alert("Setup complete!");
}
/**
 * Removes all the auto-generated sheets & triggers used by this app.
 */
function resetWorkspace(){
	deleteWorkspace();
	setup();
}
/**
 * Schedules the inventory form to be sent automatically according to the
 * interval in the settings sheet.
 */
function primeInventoryForm(){
	const reminder = createReminderService().scheduleInventoryForm();
    const msg = (reminder.wasCreated)
		? `The inventory form will now be sent every ${reminder.interval} days.`
		: "The inventory form will no longer be automatically sent.";
	SpreadsheetApp.getUi().alert(msg);
}
/**
 * Sends a form to all registered stock keepers, asking them to update the
 * quantity of each item in the inventory.
 */
function sendInventoryForm(){
    createEmailService().sendInventoryForm();
}
/**
 * Schedules the restock reminder to be sent automatically according to the
 * interval in the settings sheet.
 */
function primeRestockReminder() {
	const reminder = createReminderService().scheduleRestockReminder();
	const msg = (reminder.wasCreated)
		? `The restock reminder will now be sent every ${reminder.interval} days.`
		: "The restock reminder will no longer be automatically sent.";
	SpreadsheetApp.getUi().alert(msg);
}
/**
 * Sends an email to all registered restockers, notifying them of which items
 * in the inventory need to be restocked.
 */
function sendRestockReminder(){
    const lowOnStock = createItemService().getItemsToRestock();
    createEmailService().sendRestockReminder(lowOnStock);
}
/**
 * Runs all of the application's unit tests.
 */
function unitTests(){
	testItemModule();
	testSettings();
	testUserModule();
	SpreadsheetApp.getUi().alert("All tests passed successfully!");
}
/**
 * Runs all of the application's integration tests.
 */
function integrationTests(){
	testWorkspaceModule();
	SpreadsheetApp.getUi().alert("All tests passed successfully!");
}
// glob of newItemForm
/**
 * This module is responsible for the Google Form used to add new items to the
 * inventory.
 */
/**
 * Use this to interface with the "New Item" form component of the
 * system.
 * @param {Workspace|undefined} workspace the workspace to interface
 *  with
 * @returns the "New Item" form component of the application
 */
function newItemFormModule(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _newItemFormNameFor,
        ()=>{
            const form = _createNewItemForm(workspace.namespace);
            createSettings(workspace).setNewItemForm(form);
            return form;
        },
        _onNewItemFormSubmit
    );
}
/*
Private functions
*/
function _newItemFormNameFor(namespace=""){
    return nameFor("New item", namespace);
}
function _createNewItemForm(namespace){
    /*
    Google Forms does not support number input fields, but uses text fields with
    number validators instead. There are two important points to consider when
    handling the submitted form:
    1. some fields can be empty
    2. numerical fields must be explicitely converted from strings
    */
    const mustBeANonNegativeNumber = FormApp.createTextValidation()
        .setHelpText("Must be a non-negative number.")
        .requireNumberGreaterThanOrEqualTo(0)
        .build();
    const form = FormApp.create(_newItemFormNameFor(namespace));
    form.setDescription("Add a new item to the inventory.");
    form.setCollectEmail(true);
    form.addTextItem()
        .setTitle("Item name")
        .setRequired(true);
    form.addTextItem()
        .setTitle("How many are in the inventory now?")
        .setValidation(mustBeANonNegativeNumber);
    form.addTextItem()
        .setTitle("How many do you want to keep in the inventory at all times?")
        .setValidation(mustBeANonNegativeNumber);
    return form;
}
function _onNewItemFormSubmit(event){
    const row = event.values;
    row.shift(); // remove first cell (timestamp)
    const email = row.shift(); // remove second cell (email)
    const name = row[0];
    const quantity = parseInt(row[1]);
    const minimum = parseInt(row[2]);
    const item = new Item(
        name,
        (isNaN(quantity)) ? undefined : quantity,
        (isNaN(minimum)) ? undefined : minimum
    );
    console.log({
        event: `New item submitted by ${email}`,
        item: item
    });
    createItemService().handleNewItem(item);
    Workspace.current().itemsChanged();
}
// glob of removeItemForm
/**
 * This module is responsible for the Google Form used to remove an item type
 * from the inventory.
 */
function removeItemFormModule(workspace=null) {
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _removeItemFormNameFor,
        () => {
            const form = _createRemoveItemForm(workspace);
            createSettings(workspace).setRemoveItemForm(form);
            return form;
        },
        _onRemoveItemFormSubmit
    );
}
/*
Private functions
*/
function _removeItemFormNameFor(namespace="") {
    return nameFor("Remove item", namespace);
}
function _createRemoveItemForm(workspace) {
    const form = FormApp.create(_removeItemFormNameFor(workspace.namespace));
    form.setDescription("Remove an existing item from the inventory.");
    form.setCollectEmail(true);
    _populateRemoveItemForm(form, workspace);
    return form;
}
function _populateRemoveItemForm(form, workspace) {
    const service = createItemService(workspace);
    const itemNames = service.getAllEntities().map(item => item.name);
    if (itemNames.length === 0) {
        itemNames.push("---");
    }
    const dropDown = form.addListItem();
    dropDown.setTitle("Which item do you want to remove?")
        .setChoices(itemNames.map(opt => dropDown.createChoice(opt)));
}
function _onRemoveItemFormSubmit(event) {
    /**
     * Every time the form regenerates, event.values gets an extra empty string
     * appended after the timestamp. The last value in the array is the one we
     * want, so grab that one.
     */
    const name = lastNonEmpty(event.values);
    console.log({
        event: `Received remove item form from ${getEmailAddressFrom(event)}`,
        itemName: name
    });
    if (name) {
        createItemService().remove(name);
        Workspace.current().itemsChanged();
    } else {
        console.log("Name is falsey, so nothing to remove.");
    }
}
function regenerateRemoveItemFormFor(workspace=null) {
    workspace = Workspace.currentOr(workspace);
    const name = _removeItemFormNameFor(workspace.namespace);
    const sheet = workspace.workbook.getSheetByName(name);
    if (sheet === null) { // not generated yet
        removeItemFormModule(workspace).setup();
    } else {
        // remove old choices, repopulate
        const formUrl = sheet.getFormUrl();
        const form = FormApp.openByUrl(formUrl);
        form.getItems().forEach(item => form.deleteItem(item));
        _populateRemoveItemForm(form, workspace);
    }
}
// glob of settingSheet
/**
 * This module is responsible for the settings sheet created by the application
 */
function settingSheetModule(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _settingSheetNameFor,
        ()=>_setupSettingSheet(workspace) // not just _setupSettingSheet
    );
}
function _settingSheetNameFor(namespace=""){
    return nameFor("settings", namespace);
}
function _setupSettingSheet(workspace){
    const name = _settingSheetNameFor(workspace.namespace);
    const sheet = workspace.workbook.insertSheet(name);
    sheet.setFrozenRows(1);
    const headers = ["name", "value", "description"];
    sheet.appendRow(headers);
    const service = createSettings(workspace);
    service.populateDefaults();
    service.setWorkbook(workspace.workbook);
}
function createSettings(workspace=null){
    workspace = Workspace.currentOr(workspace);
    const name = _settingSheetNameFor(workspace.namespace);
    const sheet = workspace.workbook.getSheetByName(name);
    const repo = _makeGoogleSheetsSettingRepository(sheet);
    const service = new Settings(
        (name) => repo.getEntityByKey(name),
        (k, v) => {
            const old = repo.getEntityByKey(k);
            const updated = new Setting(k, v, old.description);
            repo.update(updated);
        },
        (setting)=>repo.addEntity(setting)
    )
    return service;
}
function _makeGoogleSheetsSettingRepository(sheet){
    return new GoogleSheetsRepository(
        sheet,
        setting => setting.name,
        setting => [setting.name, setting.value, setting.description],
        row => new Setting(row[0], row[1], row[2])
    );
}
// glob of userForm
/**
 * This module is responsible for the Google Form used to add new users to the
 * user sheet.
 */
function userFormModule(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _userFormNameFor,
        ()=>{
            const form = _createUserForm(workspace.namespace);
            createSettings(workspace).setUserForm(form);
            return form;
        },
        _onUserFormSubmit
    );
}
function _userFormNameFor(namespace){
    return nameFor("user form", namespace);
}
function _createUserForm(namespace){
    const mustBeEmail = FormApp.createTextValidation()
        .setHelpText("Must be an email address")
        .requireTextIsEmail()
        .build();
    const form = FormApp.create(_userFormNameFor(namespace));
    form.setDescription("Sign up to receive email notifications.");
    form.addTextItem()
        .setTitle("Email")
        .setValidation(mustBeEmail)
        .setRequired(true);
    const inventory = form.addMultipleChoiceItem();
    inventory.setTitle("Would you like to receive the inventory form so you can update the inventory?")
        .setChoices([
            inventory.createChoice("No"),
            inventory.createChoice("Yes")
        ])
        .setRequired(true);
    const reply = form.addMultipleChoiceItem();
    reply.setTitle("Would you like to receive the an email whenever someone submits the inventory form?")
        .setChoices([
            reply.createChoice("No"),
            reply.createChoice("Yes")
        ])
        .setRequired(true);
    const log = form.addMultipleChoiceItem();
    log.setTitle("Would you like to receive the inventory report so you can see what's running low on stock?")
        .setChoices([
            log.createChoice("No"),
            log.createChoice("Yes")
        ])
        .setRequired(true);
    return form;
}
function _onUserFormSubmit(e){
    const row = e.values;
    row.shift(); // get rid of timestamp
    // overrides previous user preferences, which the client is OK with
    const email = row[0];
    const wantsLog = row[1] === "Yes";
    const wantsLogReply = row[2] === "Yes";
    const wantsReport = row[3] === "Yes";
    const user = new User(email, wantsLog, wantsLogReply, wantsReport);
    console.log("New user: " + JSON.stringify(user));
    createUserService().handleUserForm(user);
}
// glob of userSheet
/**
 * This module is responsible for the user sheet created by the application in
 * its host Google Spreadsheet
 */
function userSheetModule(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return new Component(
        workspace,
        _userSheetNameFor,
        ()=>_setupUserSheet(workspace) // not just _setupUserSheet
    );
}
function _setupUserSheet(workspace){
    const name = _userSheetNameFor(workspace.namespace);
    const userSheet = workspace.workbook.insertSheet(name);
    userSheet.setFrozenRows(1);
    const headers = ["email", "wants log", "wants log reply", "wants report"];
    userSheet.appendRow(headers);
    const mustBeEmail = SpreadsheetApp.newDataValidation()
        .requireTextIsEmail()
        .setAllowInvalid(false)
        .setHelpText("must be a valid email address")
        .build();
    const emailCol = userSheet.getRange("A2:A");
    emailCol.setDataValidation(mustBeEmail);
    const mustBeYesOrNo = SpreadsheetApp.newDataValidation()
        .requireValueInList(["yes", "no"])
        .setAllowInvalid(false)
        .setHelpText("must be either 'yes' or 'no', without quote marks")
        .build();
    const boolCols = userSheet.getRange("B2:D");
    boolCols.setDataValidation(mustBeYesOrNo);
}
function _userSheetNameFor(namespace=""){
    return nameFor("users", namespace);
}
/**
 * Use this to access the UserService
 * @param {Workspace|undefined} workspace the workspace to create the service in
 * @return {UserService} a UserService for interacting with this workbook
 */
function createUserService(workspace=null){
    workspace = Workspace.currentOr(workspace);
    const name = _userSheetNameFor(workspace.namespace);
    const sheet = workspace.workbook.getSheetByName(name);
    const repo = _makeGoogleSheetsUserRepository(sheet);
    const service = new UserService(repo);
    return service;
}
function _makeGoogleSheetsUserRepository(sheet){
    return new GoogleSheetsRepository(
        sheet,
        (user)=>user.email,
        (user)=>[
            user.email,
            (user.wantsLog) ? "yes" : "no",
            (user.wantsLogReply) ? "yes" : "no",
            (user.wantsReport) ? "yes" : "no"
        ],
        (row)=>new User(
            row[0],
            row[1] === "yes", // empty cells count as "no"
            row[2] === "yes",
            row[3] === "yes"
        )
    );
}
// glob of workspace
/**
 * This module is responsible for integrating with Google Workspace. By doing so
 * in a separate file from the bulk of the system, third-party dependencies are
 * isolated from the core system, allowing it to more easily port between
 * implementations.
 *
 * About NAMESPACES:
 *  since some of the project's tests must interact with Google sheets, there
 *  must be some way of preventing those tests from modifying the sheets used
 *  by the application. To do this, NAMESPACES can be included in a sheet name
 *  to designate who they belong to. This is done through the nameFor function:
 *      nameFor(resourceName, namespace)
 */
const FORM_HANDLER_NAME = onFormSubmit.name;
/*
this does not automatically start handling forms, and is explicitly registered
in _setupFormHandler
*/
function onFormSubmit(e){
    console.log({
        event: "Received Google form",
        form: JSON.stringify(e)
    });
    /*
    ugly duck-typing, but it looks like e doesn't have any other way of knowing
    which form submitted it
    */
    if("Item name" in e.namedValues){
        newItemFormModule().receiveForm(e);
    } else if("Email" in e.namedValues){
        userFormModule().receiveForm(e);
    } else if("Which item do you want to remove?" in e.namedValues) {
        removeItemFormModule().receiveForm(e);
    } else {
        inventoryFormModule().receiveForm(e);
    }
}
/**
 * Represents a virtual worksheet, which is the combination of a Google
 * Spreadsheet (the whole workbook, not just one sheet), as well as a namespace,
 * which as prepended to sheet names. A workbook can contain multiple namespaces
 */
class Workspace {
    /**
     * @param {SpreadsheetApp.Spreadsheet} workbook the Google Spreadsheet this
     *  represents
     * @param {string} namespace the namespace within the workbook this
     *  represents
     */
    constructor(workbook, namespace) {
        this.workbook = workbook;
        this.namespace = namespace;
    }
    /**
     * @returns {Workspace} the current workspace the app is executing in
     */
    static current() {
        return new Workspace(SpreadsheetApp.getActiveSpreadsheet(), "");
    }
    /**
     * @param {Workspace|null} other possibly another workspace
     * @returns either the current workspace or the given workspace, if it is
     *  not null
     */
    static currentOr(other=null) {
        return (other === null) ? Workspace.current() : other;
    }
    /**
     * Notifies this that the types of items in the inventory have changed, and
     * thus various forms should be regenerated.
     */
    itemsChanged() {
        createSettings(this).setInventoryFormStale(true);
        regenerateRemoveItemFormFor();
    }
}
/*
Circumvents the Google script inheritance issue caused by unpredictable
script execution order. Also note that inheritance does not work as expected
even when used in the same file as the superclass.
*/
class Component {
    /**
     * @param {Workspace} workspace the workspace this component exists in
     * @param {(string)=>string} namespaceToName maps the namespace to the name
     *  of the sheet for this component in that namespace
     * @param {()=>Form|null|undefined} create creates this sheet if it doesn't
     *  exist. It should return the form if one was created.
     * @param {(FormEvent)=>void} onSubmit handles form submissions.
     */
    constructor(workspace, namespaceToName, create, onSubmit){
        this.workspace = workspace;
        this.name = namespaceToName(workspace.namespace);
        this.create = create;
        this.onSubmit = onSubmit;
    }
    setup(){
        // does not bind 'this' context with just "this._doSetup"
        ifSheetDoesNotExist(this.workspace.workbook, this.name, ()=>this._doSetup());
    }
    _doSetup(){
        const formOrMaybeNot = this.create();
        if(formOrMaybeNot && formOrMaybeNot.setDestination){
            this._doSetupForm(formOrMaybeNot);
        }
    }
    _doSetupForm(form){
        form.setDestination(
            FormApp.DestinationType.SPREADSHEET,
            this.workspace.workbook.getId()
        );
        /*
        The form is created using the Google Forms service instead of the Sheets
        service, so the call to setDestination does not alter workbook. Sheets
        caches the contents of the spreadsheet when it is accessed using
        SpreadsheetApp, and the contents are only updated when a writing
        function is used. Since getSheets is a reading call, it reads the cached
        list of sheets, which excludes the newly created destination sheet.
        https://issuetracker.google.com/issues/36764101
        */
        SpreadsheetApp.flush(); // updates the workbook variable
        // rename the sheet created by setDestination so it's easier to find
        // this URL solution doesn't work: https://stackoverflow.com/a/51484165
        const formId = form.getId();
        const createdSheet = this.workspace.workbook.getSheets().filter(sheet => {
            return null !== sheet.getFormUrl();
        }).find(sheet => {
            const form = FormApp.openByUrl(sheet.getFormUrl());
            return form.getId() === formId;
        });
        createdSheet.setName(this.name);
        createdSheet.hideSheet();
    }
    delete(){
        deleteSheet(this.workspace.workbook, this.name);
    }
    receiveForm(event){
        this.onSubmit(event);
    }
}
function getEmailAddressFrom(form) {
    return form.namedValues["Email Address"].at(-1);
}
/**
 * Needed because of how Google Forms responses are formatted.
 * @param {String[]} array the array to find the last non-empty string in
 * @returns the last non-empty string in the given array
 */
function lastNonEmpty(array) {
    return array.findLast(e => e !== "");
}
function allModulesFor(workspace=null){
    workspace = Workspace.currentOr(workspace);
    return [
        settingSheetModule(workspace), // must be first
        inventorySheetModule(workspace),
        userSheetModule(workspace),
        userFormModule(workspace),
        newItemFormModule(workspace),
        inventoryFormModule(workspace),
        removeItemFormModule(workspace)
    ];
}
/**
 * Mutates the given workbook into a suitable environment for the application.
 * @param {Workspace|undefined} workspace the environment to mutate
 */
function setupWorkspace(workspace=null){
    workspace = Workspace.currentOr(workspace);
    allModulesFor(workspace).forEach(m=>m.setup());
    _setupFormHandler(workspace.workbook);
}
function _setupFormHandler(workbook){
    const triggers = ScriptApp.getProjectTriggers();
    const formSubmitTrigger = triggers.find(t => t.getHandlerFunction() === FORM_HANDLER_NAME);
    if(!formSubmitTrigger){
        ScriptApp.newTrigger(FORM_HANDLER_NAME)
            .forSpreadsheet(workbook)
            .onFormSubmit()
            .create();
    }
}
function deleteWorkspace(workspace=null){
    workspace = Workspace.currentOr(workspace);
    allModulesFor(workspace).forEach(m=>m.delete());
    if("" === workspace.namespace){
        const triggers = ScriptApp.getProjectTriggers();
        const formSubmitTrigger = triggers.find(t => {
            return t.getHandlerFunction() === FORM_HANDLER_NAME;
        });
        if(formSubmitTrigger !== null){
            ScriptApp.deleteTrigger(formSubmitTrigger);
        }
    }
}
/**
 * Deletes a sheet and any attached formsfrom the workbook if the sheet exists.
 * @param {SpreadsheetApp.Spreadsheet} workbook
 * @param {string} sheetName
 */
function deleteSheet(workbook, sheetName){
    const sheet = workbook.getSheetByName(sheetName);
    if(sheet !== null){
        const formUrl = sheet.getFormUrl();
        if(formUrl !== null){
            // delete attached form
            const form = FormApp.openByUrl(formUrl);
            form.removeDestination();
            const file = DriveApp.getFileById(form.getId());
            file.setTrashed(true);
        }
        workbook.deleteSheet(sheet);
    }
}
/**
 * @param {SpreadsheetApp.Spreadsheet} workbook
 * @param {string} sheetName
 * @param {void function(string)} doThis
 */
function ifSheetDoesNotExist(workbook, sheetName, doThis){
    if(null === workbook.getSheetByName(sheetName)){
        doThis(sheetName);
    }
}
/**
 * Each workbook should support multiple namespaces for testing purposes, though
 * should also support a default, unspecified namespace
 * @param {string} resource - sheet or form name
 * @param {string|undefined} namespace
 * @returns the name for the given sheet within the given namespace
 */
function nameFor(resource, namespace=""){
    mustHaveValue(resource);
    mustHaveValue(namespace);
    return ("" === namespace) ? resource : `${namespace}-${resource}`;
}
/*
Unit tests
*/
function testWorkspaceModule(){
    const workspace = new Workspace(
        SpreadsheetApp.getActiveSpreadsheet(),
        "test"
    );
    deleteWorkspace(workspace);
    setupWorkspace(workspace);
    testNameFor();
    testEmailModule();
    testGoogleSheetsItemRepository(workspace.workbook);
    /*
    only remove test sheets if tests are successful, as this allows us to
    diagnose errors if one of these tests fails
    */
    deleteWorkspace(workspace);
}
function testNameFor(){
    const sheetName = "foo";
    const namespace = "bar";
    const sheetWithoutNamespace = nameFor(sheetName);
    assert(sheetWithoutNamespace.includes(sheetName));
    const sheetWithNamespace = nameFor(sheetName, namespace);
    assert(sheetWithNamespace.includes(sheetName));
    assert(sheetWithNamespace.includes(namespace));
}
