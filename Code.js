// This file has been generated by catgs.py
// glob of orm
// maybe try to abstractify this into both inmemory and gsrepo
class Repository {
    constructor(){
    }
    addEntity(entity){
    }
    hasEntityWithKey(key){
    }
}
/**
 * stores entities in a Google sheet
 */
class GoogleSheetsRepository {
    /**
     * @param {SpreadsheetApp.Spreadsheet} sheet stores entities
     * @param {(TEntity)=>TKey} getKey extracts the primary key for an entity
     * @param {(TEntity)=>any[]} toRow converts an entity to a sheet row. The primary key must go in the first column
     * @param {(any[])=>TEntity} toEntity converts a row to an entity
     */
    constructor(sheet, getKey, toRow, toEntity){
        this._sheet = sheet;
        this._getKey = getKey;
        this._toRow = toRow;
        this._toEntity = toEntity;
    }
    addEntity(entity){
        const key = this._getKey(entity);
        if(this.hasEntityWithKey(key)){
            throw new Error(`Duplicate key: ${key}`);
        }
        this._sheet.appendRow(this._toRow(entity));
    }
    hasEntityWithKey(key){
        const allKeys = this._sheet.getRange("A2:A").getValues().map(row=>row[0]);
        return allKeys.includes(key);
    }
    getEntityByKey(key){
        if(!this.hasEntityWithKey(key)){
            throw new Error(`No entity with key: ${key}`);
        }
        const rows = this._sheet.getDataRange().getValues();
        rows.shift(); // remove header
        const idx = rows.findIndex(row => row[0] === key);
        return this._toEntity(rows[idx]);
    }
    getAllEntities(){
        const rows = this._sheet.getDataRange().getValues();
        rows.shift();
        return rows.map(row=>this._toEntity(row));
    }
    update(entity){
        const key = this._getKey(entity);
        if(!this.hasEntityWithKey(key)){
            throw new Error(`No entity with key, so cannot update: ${key}`);
        }
        const rows = this._sheet.getDataRange().getValues();
        rows.shift();
        const idx = rows.findIndex(row=>row[0] === key);
        const newRow = this._toRow(entity);
        //                      translate from 0 to 1 idx, +1 for header
        this._sheet.getRange(idx + 2, 1, 1, newRow.length).setValues([newRow]);
    }
}
// glob of product
/**
 * This module is responsible for services related to ProductTypes
 *
 * Data class: ProductType
 * #----------#--------#
 * |     name | string |
 * | quantity | int    |
 * |  minimum | int    |
 * #----------#--------#
 */
/**
 * the ProductType class represents a type of product that can be tracked by the
 * system and the various tracking parameters associated with the product
 */
class ProductType {
    /**
     * @param {string} name - an identifier for this type of product
     * @param {number} quantity - the amount of this product currently in stock
     * @param {number} minimum - the system will report when quantity <= minimum
     * @param {number} notificationInterval - how often the stock keeper should
     *  be asked to update the quantity of this product type (measured in days)
     */
    constructor(name, quantity=0, minimum=0){
        mustHaveValue(name);
        mustHaveValue(quantity);
        mustBeNonNegative(quantity);
        mustHaveValue(minimum);
        mustBeNonNegative(minimum);
        this.name = normalizeProductTypeName(name);
        this.quantity = quantity;
        this.minimum = minimum;
    }
    dataEquals(other){
        return this.name === other.name &&
            this.quantity === other.quantity &&
            this.minimum === other.minimum;
    }
    copy(){
        return new ProductType(this.name, this.quantity, this.minimum);
    }
}
/**
 * provides the interface for CRUD operations on ProductTypes
 *
 * because of how Google script concatinates files together, class extension
 * does not work, so this class does nothing but provide developer guidelines
 */
class AbstractProductTypeRepository {
    /**
     * records a new ProductType in the repository
     * subclasses are responsible for deciding how to handle adding a
     * ProductType whose name is already used
     *
     * @param {ProductType} productType
     */
    addEntity(productType){
        throw new Error("addEntity is not implemented");
    }
    /**
     * @param {string} name
     * @returns {boolean} whether this repository has a ProductType with the
     *  given name
     */
    hasEntityWithKey(name){
        throw new Error("hasEntityWithKey is not implemented");
    }
    /**
     * retrieves the ProductType whose name matches the given name
     * subclasses are responsible for deciding how to handle getting a name for
     * which the exists no product
     *
     * @param {string} name
     * @returns {ProductType}
     */
    getEntityByKey(name){
        throw new Error("getEntityByKey is not implemented");
    }
    /**
     * @returns {ProductType[]}
     */
    getAllEntities(){
        throw new Error("getAllEntities is not implemented");
    }
    /**
     * Changes the ProductType in this repository whose name matches that of the
     * given parameter so that its data matches that of the parameter.
     * Subclasses are responsible for how to handle updating a ProductType that
     * does not exist in the repository.
     *
     * @param {ProductType} productType
     */
    update(productType){
        throw new Error("update is not implemented");
    }
}
/**
 * ProductTypes are considered equal if their names are the same, ignoring case
 *
 * @param {string} name
 * @returns the normalized product type name
 */
function normalizeProductTypeName(name){
    return name.toLowerCase();
}
/**
 * This non-persistant ProductType repository used for testing
 */
class InMemoryProductTypeRepository extends AbstractProductTypeRepository {
    constructor(products=[]){
        super();
        this.products = new Map();
        products.forEach(product => this.products.set(
            normalizeProductTypeName(product.name),
            product
        ));
    }
    addEntity(productType){
        const name = normalizeProductTypeName(productType.name);
        if(this.hasEntityWithKey(name)){
            throw new Error(`Product already exists with name "${name}"`);
        }
        this.products.set(name, productType.copy());
    }
    hasEntityWithKey(name){
        return this.products.has(normalizeProductTypeName(name));
    }
    getEntityByKey(name){
        if(!this.hasEntityWithKey(name)){
            throw new Error(`No product type with name "${name}"`);
        }
        return this.products.get(normalizeProductTypeName(name)).copy();
    }
    getAllEntities(){
        return Array.from(this.products.values()).map(pt => pt.copy());
    }
    update(productType){
        const name = normalizeProductTypeName(productType.name);
        if(!this.hasEntityWithKey(name)){
            throw new Error(`Cannot update product type with name "${name}", as no product with that name exists`);
        }
        this.products.set(name, productType);
    }
}
/**
 * The ProductTypeService handles ProductTypes business logic
 */
class ProductTypeService {
    /**
     * @param {AbstractProductTypeRepository} repository
     */
    constructor(repository){
        this.repository = repository;
    }
    /**
     * @returns {ProductType[]}
     */
    getAllEntities(){
        return this.repository.getAllEntities();
    }
    /**
     * @param {ProductType} product
     */
    handleNewProduct(product){
        if(this.repository.hasEntityWithKey(product.name)){
            this.repository.update(product);
        } else {
            this.repository.addEntity(product);
        }
    }
    /**
     * @param {ProductType[]} changes
     */
    handleLogForm(changes){
        /*
        the products created by the log form have no "minimum" field, so need to
        retrieve that field from the current repository
        */
        const oldProducts = this.repository.getAllEntities();
        const nameToProductType = new Map();
        oldProducts.forEach(product=>nameToProductType.set(product.name, product));
        changes.forEach(change=>{
            if(!nameToProductType.has(change.name)){
                console.error(`Log form contains new product: ${change.name}. Maybe regenerate the stock update form?`);
            }
            nameToProductType.get(change.name).quantity = change.quantity;
        });
        for(const changedProduct of nameToProductType.values()){
            this.repository.update(changedProduct);
        }
    }
}
/**
 * runs all unit tests for this module, throwing an exception if any fail
 */
function testProductTypeModule(){
    testProductType();
    testInMemoryProductTypeRepository();
    testProductTypeService();
}
function testProductType(){
    // any defined name is OK
    const name = "foo";
    new ProductType(name);
    assertThrows(()=>new ProductType(undefined));
    assertThrows(()=>new ProductType(null));
    // amount must be defined and non-negative
    const amount = 5;
    new ProductType(name, amount);
    new ProductType(name, 0);
    assertThrows(()=>new ProductType(name, null));
    assertThrows(()=>new ProductType(name, -amount));
    // minimum must be defined and non-negative
    const minimum = 3;
    new ProductType(name, amount, minimum);
    new ProductType(name, amount, 0);
    assertThrows(()=>new ProductType(name, amount, null));
    assertThrows(()=>new ProductType(name, amount, -minimum));
}
function testInMemoryProductTypeRepository(){
    const data = new ProductType("foo");
    const productTypeComparator = (a, b) => a.dataEquals(b);
    let sut = new InMemoryProductTypeRepository();
    sut.addEntity(data);
    assertContains(data, sut.products.values(), productTypeComparator);
    sut = new InMemoryProductTypeRepository([data]);
    let actual = sut.getEntityByKey(data.name);
    assert(data.dataEquals(actual));
    const values = ["foo", "bar", "baz"].map(n => new ProductType(n));
    sut = new InMemoryProductTypeRepository(values);
    actual = sut.getAllEntities();
    assert(3 === actual.length);
    assertContains(values[0], actual, productTypeComparator);
    assertContains(values[1], actual, productTypeComparator);
    assertContains(values[2], actual, productTypeComparator);
    sut = new InMemoryProductTypeRepository([data]);
    let changed = data.copy();
    changed.quantity += 1;
    sut.update(changed);
    actual = sut.getEntityByKey(data.name);
    assert(changed.dataEquals(actual));
    assert(!data.dataEquals(actual));
}
function testProductTypeService(){
    const productTypeComparator = (a, b) => a.dataEquals(b);
    const exists = new ProductType("foo");
    const repo = new InMemoryProductTypeRepository([exists]);
    const sut = new ProductTypeService(repo);
    const expected = [
        exists.copy()
    ];
    expected[0].quantity += 1;
    sut.handleLogForm(expected);
    const actual = repo.getAllEntities();
    assert(expected.length === actual.length);
    assertContains(expected[0], actual, productTypeComparator);
    assertDoesNotContain(exists, actual);
}
// glob of settings
/**
 * This module is responsible for the the settings system the program uses.
 * Settings are essentially key-value pairs with a description attached.
 */
class Settings {
    /**
     *
     * @param {(key: string)=>Setting} getter returns the Setting for the given
     *  key, or null if not set
     * @param {(key: string, value: any)=>any} setter assigns the given
     *  value to the given setting
     * @param {(setting: Setting)=>any} defineSetting defines a new setting
     */
    constructor(getter, setter, defineSetting){
        this._get = getter;
        this._set = setter;
        this._define = defineSetting;
    }
    populateDefaults(){
        DEFAULT_SETTINGS.forEach(setting=>this._define(setting));
    }
    get(key){
        return this._get(key).value;
    }
    set(key, value){
        this._set(key, value);
    }
    defineSetting(key, value, description=""){
        this._define(new Setting(key, value, description));
    }
    getStockUpdateFormInterval(){
        return this.get("stock update form interval");
    }
    setStockUpdateFormStale(isStale){
        this.set("stock update form is stale", (isStale) ? "yes" : "no");
    }
    isStockUpdateFormStale(){
        return this.get("stock update form is stale") === "yes";
    }
    setUserForm(form){
        this.set("User form URL", form.getPublishedUrl());
    }
    getUserFormUrl(){
        return this.get("User form URL");
    }
    setStockUpdateForm(form){
        this.set("Stock update form URL", form.getPublishedUrl());
    }
    getStockUpdateFormUrl(){
        return this.get("Stock update form URL");
    }
    setNewProductTypeForm(form){
        this.set("New product type form URL", form.getPublishedUrl());
    }
    getNewProductTypeFormUrl(){
        return this.get("New product type form URL");
    }
    setWorkbook(workbook){
        this.set("Workbook URL", workbook.getUrl());
    }
    getWorkbookUrl(){
        return this.get("Workbook URL");
    }
}
class Setting {
    constructor(name, value, description=""){
        this.name = name;
        this.value = value;
        this.description = description;
    }
}
const DEFAULT_SETTINGS = [
    new Setting("stock update form interval", 7, "The number of days between sendings of the stock update form"),
    new Setting("stock update form is stale", "no", "'yes' when the system will regenerate the stock update form"),
    new Setting("User form URL", "", "Use this form to sign up for notifications or change your preferences"),
    new Setting("Stock update form URL", "", "Use this form to update the items in stock"),
    new Setting("New product type form URL", "", "Use this form to record a new product type in the stock"),
    new Setting("Workbook URL", "", "The URL of this workbook")
];
function testSettings(){
    const settings = new Map();
    const sut = new Settings(
        (key)=>settings.get(key),
        (key, value)=>settings.get(key).value = value,
        (setting)=>settings.set(setting.name, setting)
    );
    sut.populateDefaults();
    mustBeDefined(sut.get("stock update form interval"));
}
// glob of user
/**
 * This module is responsible for services related to Users
 *
 * Data class: User
 * #-------------#---------#
 * |       email | string  |
 * |    wantsLog | boolean |
 * | wantsReport | boolean |
 * #-------------#---------#
 */
class User {
    /**
     *
     * @param {string} email
     * @param {boolean|undefined} wantsLog - true if this user should receive
     *  the stock update form
     * @param {boolean|undefined} wantsReport - true if this user should receive
     *  the restocking report email
     */
    constructor(email, wantsLog=false, wantsReport=false){
        mustHaveValue(email);
        this.email = email;
        this.wantsLog = wantsLog;
        this.wantsReport = wantsReport;
    }
    dataEquals(other){
        return this.email === other.email
            && this.wantsLog === other.wantsLog
            && this.wantsReport === other.wantsReport;
    }
    copy(){
        return new User(this.email, this.wantsLog, this.wantsReport);
    }
}
class InMemoryUserRepository {
    constructor(users=[]){
        this.users = new Map();
        users.forEach(u=>this.users.set(u.email, u));
    }
    addEntity(user){
        if(this.hasEntityWithKey(user.email)){
            throw new Error(`User already exists with email = "${user.email}"`);
        }
        this.users.set(user.email, user.copy());
    }
    hasEntityWithKey(email){
        return this.users.has(email);
    }
    getEntityByKey(email){
        if(!this.hasEntityWithKey(email)){
            throw new Error(`No user has email = "${email}"`);
        }
        return this.users.get(email).copy();
    }
    getAllEntities(){
        return Array.from(this.users.values()).map(u=>u.copy());
    }
    update(user){
        if(!this.hasEntityWithKey(user.email)){
            throw new Error(`No user has email = "${user.email}"`);
        }
        this.users.set(user.email, user);
    }
}
class UserService {
    constructor(repo){
        this.users = repo;
    }
    /**
     * @returns {string[]} the email addresses of users who want the stock
     *  update form
     */
    getStockUpdateFormEmails(){
        return this.users.getAllEntities().filter(u=>u.wantsLog).map(u=>u.email);
    }
    handleUserForm(user){
        if(this.users.hasEntityWithKey(user.email)){
            this.users.update(user);
        } else {
            this.users.addEntity(user);
        }
    }
}
function testUserModule(){
    const wantsLog = "baz.qux@gmail.com";
    const doesNotWantLog = "foo.bar@gmail.com";
    const users = [
        new User(doesNotWantLog),
        new User(wantsLog, true, true)
    ];
    const repo = new InMemoryUserRepository(users);
    const sut = new UserService(repo);
    const actual = sut.getStockUpdateFormEmails();
    assertContains(wantsLog, actual);
    assertDoesNotContain(doesNotWantLog, actual);
}
// glob of utilities
/**
 * This module contains miscillaneous utilities.
 *
 * void assert(boolean, string?)
 * void assertThrows(void function())
 * void assertContains(T, T[], boolean function(T, T))
 * void assertDoesNotContain(T, T[], boolean function(T, T))
 *
 * void mustBeNonNegative(number)
 * void mustBeNumber(obj)
 * void mustBePositive(number)
 *
 * void mustBeDefined(*)
 * void mustHaveValue(*)
 */
function assert(bool, msg=""){
    if(!bool){
        throw new Error(msg);
    }
}
function assertThrows(fn){
    let anExceptionWasThrown = false;
    try {
        fn();
    } catch(ex){
        anExceptionWasThrown = true;
    }
    if(!anExceptionWasThrown){
        throw new Error("Function failed to throw an error");
    }
}
function assertContains(item, collection, comparator=(a, b)=>a===b){
    if(!Array.from(collection).some((curr)=>comparator(curr, item))){
        throw new Error(`${collection} does not contain ${item}`);
    }
}
function assertDoesNotContain(item, collection, comparator=(a, b)=>a===b){
    if(Array.from(collection).some((curr)=>comparator(curr, item))){
        throw new Error(`${collection} does contains ${item}`);
    }
}
function mustBePositive(num){
    mustBeNumber(num);
    if(num <= 0){
        throw new Error(`Value must be positive: ${num}`);
    }
}
function mustBeNumber(obj){
    const rightType = typeof(obj) === typeof(1);
    const isNum = rightType && !isNaN(obj);
    if(!isNum){
        throw new Error(`Value must be a number: ${obj}`);
    }
}
function mustBeNonNegative(num){
    mustBeNumber(num);
    if(num < 0){
        throw new Error(`Value must be non-negative: ${num}`);
    }
}
function mustBeDefined(obj){
    if(undefined === obj){
        throw new Error("Value cannot be undefined");
    }
}
function mustHaveValue(obj){
    mustBeDefined(obj)
    if(null === obj){
        throw new Error("Value cannot be null");
    }
}
// glob of email
/**
 * This module is responsible for sending the stock update form and report email
 *
 * https://developers.google.com/apps-script/reference/mail
 */
function createEmailService(workbook=null, namespace=""){
    if(workbook===null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    const users = createUserService(workbook, namespace);
    const emailSender = (email)=>MailApp.sendEmail({
        to: email.to.join(","),
        subject: email.subject,
        htmlBody: email.bodyHtml
    });
    const settings = createSettings(workbook, namespace);
    const regenForm = ()=>regenerateStockUpdateFormFor(workbook, namespace);
    return new EmailService(users, emailSender, settings, regenForm);
}
class Email {
    constructor(to=[], subject="", bodyHtml=""){
        if(!Array.isArray(to)){
            to = [to];
        }
        this.to = to;
        this.subject = subject;
        this.bodyHtml = bodyHtml;
    }
}
class EmailService {
    /**
     * @param {UserService} userService used to get lists of users who want
     *  each email type.
     * @param {(email)=>any} sendEmail sends emails
     * @param {Settings} settings contains email settings
     * @param {()=>null} regenerateStockUpdateForm regenerates the stock update
     *  form if it is stale.
     */
    constructor(userService, sendEmail, settings, regenerateStockUpdateForm){
        this._users = userService;
        this._sendEmail = sendEmail;
        this._settings = settings;
        this._regenerateStockUpdateForm = regenerateStockUpdateForm;
    }
    sendStockUpdateForm(){
        if(this._settings.isStockUpdateFormStale()){
            this._regenerateStockUpdateForm();
        }
        const to = this._users.getStockUpdateFormEmails();
        if(to.length === 0){
            throw new Error("Nobody wants the stock update form");
        }
        const newProdUrl = this._settings.getNewProductTypeFormUrl();
        const stockUrl = this._settings.getStockUpdateFormUrl();
        const sheetUrl = this._settings.getWorkbookUrl();
        const userUrl = this._settings.getUserFormUrl();
        const lines = [
            "This email was generated by the Google Workspace Inventory Tracker.",
            `This form adds a new item to your inventory: ${newProdUrl}.`,
            `This form updates the items already recorded in your inventory: ${stockUrl}`,
            `You can view your inventory here: ${sheetUrl}`,
            `You can change your notification preferences here: ${userUrl}`
        ];
        const email = new Email(
            to,
            "It's time to update our inventory!",
            lines.map(line => `<p>${line}</p>`).join("\n")
        );
        this._sendEmail(email);
    }
    updateTrigger(){
        const oldTriggers = ScriptApp.getProjectTriggers().filter(t => {
            return t.getHandlerFunction() === sendStockUpdateForm.name;
        });
        oldTriggers.forEach(t => ScriptApp.deleteTrigger(t));
        const interval = this._settings.getStockUpdateFormInterval();
        let msg = "The stock update form will no longer be automatically sent.";
        if(!isNaN(parseInt(interval))){
            ScriptApp.newTrigger(sendStockUpdateForm.name)
                .timeBased()
                .everyDays(interval)
                .create();
            msg = `The stock update form will now be sent every ${interval} days.`;
        }
        return msg;
    }
}
function sendStockUpdateForm(){
    createEmailService().sendStockUpdateForm();
}
function primeStockUpdateForm(){
    const msg = createEmailService().updateTrigger();
    SpreadsheetApp.getUi().alert(msg);
}
function testEmailModule(){
    const sentEmails = new Map();
    const users = [
        new User("foo.bar@gmail.com", true, false),
        new User("baz.qux@gmail.com", false, false)
    ];
    const repo = new InMemoryUserRepository(users);
    const userService = new UserService(repo);
    let settings = {};
    const emailRecorder = (email)=>{
        email.to.forEach(addr=>{
            if(!sentEmails.has(addr)){
                sentEmails.set(addr, []);
            }
            sentEmails.get(addr).push(email);
        });
    };
    const settingService = new Settings(
        k => settings[k],
        (k, v)=> {
            if(!settings[k]){
                settings[k] = new Setting(k, v);
            } else {
                settings[k].value = v;
            }
        },
        setting => settings[setting.name] = setting
    );
    settingService.populateDefaults();
    const emailService = new EmailService(
        userService,
        emailRecorder,
        settingService,
        ()=>settingService.setStockUpdateFormStale(false)
    );
    emailService.sendStockUpdateForm();
    assert(sentEmails.has("foo.bar@gmail.com"));
    assert(1 === sentEmails.get("foo.bar@gmail.com").length);
    assert(!sentEmails.has("baz.qux@gmail.com"));
}
// glob of inventorySheet
/**
 * This module is responsible for the inventory sheet created by the application
 * in its host Google Spreadsheet.
 */
 function inventorySheetModule(workbook, namespace){
    return new Component(
        workbook,
        namespace,
        _inventorySheetNameFor,
        (ns)=>_setupInventorySheet(workbook, ns)
    );
}
function _inventorySheetNameFor(namespace){
    return nameFor("inventory", namespace);
}
function _setupInventorySheet(workbook, namespace){
    const inventorySheet = workbook.insertSheet(_inventorySheetNameFor(namespace));
    inventorySheet.setFrozenRows(1);
    const validation = SpreadsheetApp.newDataValidation()
        .requireNumberGreaterThanOrEqualTo(0)
        .setAllowInvalid(false)
        .setHelpText("Quantity and minimum must both be a number at least 0")
        .build();
    const quantityAndMinimumColumns = inventorySheet.getRange("B2:C");
    quantityAndMinimumColumns.setDataValidation(validation);
    const headers = ["name", "quantity", "minimum"];
    inventorySheet.appendRow(headers);
}
/**
 * @param {string|undefined} namespace
 * @returns {ProductTypeService} an instance of ProductTypeService backed by a Google sheet as its
 *  repository
 */
function createProductService(namespace=""){
    const workbook = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = workbook.getSheetByName(_inventorySheetNameFor(namespace));
    const repo = makeGoogleSheetsProductTypeRepository(sheet);
    const service = new ProductTypeService(repo);
    return service;
}
function makeGoogleSheetsProductTypeRepository(sheet){
    return new GoogleSheetsRepository(
        sheet,
        (productType)=>productType.name,
        (productType)=>[productType.name, productType.quantity, productType.minimum],
        (row)=>new ProductType(
            row[0],
            (row[1] === "") ? undefined : row[1], // catch empty cells
            (row[2] === "") ? undefined : row[2]
        )
    );
}
function testGoogleSheetsProductTypeRepository(workbook){
    const sheet = workbook.getSheetByName(_inventorySheetNameFor("test"));
    const sut = makeGoogleSheetsProductTypeRepository(sheet)
    const expected = new ProductType("product");
    sut.addEntity(expected);
    assert(sut.hasEntityWithKey(expected.name));
    assert(!sut.hasEntityWithKey("not " + expected.name));
    const actual = sut.getEntityByKey(expected.name);
    assert(expected.dataEquals(actual));
    const all = sut.getAllEntities();
    assert(1 === all.length, `length should be 1, not ${all.length}`);
    assert(expected.dataEquals(all[0]));
}
// glob of main
/**
 * this module is responsible for loading interacting with the Google Sheets UI
 */
/**
 * called automatically upon opening the Google Spreadsheet
 */
function onOpen(){
	const ui = SpreadsheetApp.getUi();
	ui.createMenu("G-WIT")
		.addItem("Set up", "setup")
		.addItem("Reset workspace", "resetWorkspace")
		.addItem("Regenerate stock update form", "regenerateStockUpdateForm")
		.addItem("Send stock update form", sendStockUpdateForm.name)
		.addItem("Prime stock update form", primeStockUpdateForm.name)
		.addItem("Run unit tests (fast)", "unitTests")
		.addItem("Run integration tests (slow)", "integrationTests")
		.addToUi();
}
/**
 * mutates the current Google Sheet into a suitable environment for the program
 */
function setup(){
	const workbook = SpreadsheetApp.getActiveSpreadsheet();
	setupWorkspace(workbook);
	SpreadsheetApp.getUi().alert("Setup complete!");
}
/**
 * a testing function that removes all the auto-generated Google Workspace stuff
 */
function resetWorkspace(){
	const workbook = SpreadsheetApp.getActiveSpreadsheet();
	deleteWorkspace(workbook);
	setup();
}
/**
 * this might be temporary
 */
function regenerateStockUpdateForm(){
	regenerateStockUpdateFormFor(SpreadsheetApp.getActiveSpreadsheet());
}
function unitTests(){
	testProductTypeModule();
	testSettings();
	testUserModule();
	SpreadsheetApp.getUi().alert("All tests passed successfully!");
}
function integrationTests(){
	testWorkspaceModule();
	SpreadsheetApp.getUi().alert("All tests passed successfully!");
}
// glob of newProductTypeForm
/**
 * This module is responsible for the Google Form used to add new product types
 * to the inventory.
 */
/**
 * Use this to interface with the "New Product Type" form component of the
 * system.
 * @param {SpreadsheetApp.Spreadsheet|null} workbook
 * @param {string|undefined} namespace
 * @returns the "New Product Type" form component of the application
 */
function newProductTypeFormModule(workbook=null, namespace=""){
    if(workbook === null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    return new Component(
        workbook,
        namespace,
        _newProductTypeFormNameFor,
        (ns)=>{
            const form = _createNewProductTypeForm(ns);
            createSettings(workbook, namespace).setNewProductTypeForm(form);
            return form;
        },
        _onNewProductTypeFormSubmit
    );
}
/*
Private functions
*/
function _newProductTypeFormNameFor(namespace=""){
    return nameFor("New Product Type", namespace);
}
function _createNewProductTypeForm(namespace){
    /*
    Google Forms does not support number input fields, but uses text fields with
    number validators instead. There are two important points to consider when
    handling the submitted form:
    1. some fields can be empty
    2. numerical fields must be explicitely converted from strings
    */
    const mustBeANonNegativeNumber = FormApp.createTextValidation()
        .setHelpText("Must be a non-negative number.")
        .requireNumberGreaterThanOrEqualTo(0)
        .build();
    const mustBeAPositiveNumber = FormApp.createTextValidation()
        .setHelpText("Must be a positive number.")
        .requireNumberGreaterThan(0)
        .build();
    const form = FormApp.create(_newProductTypeFormNameFor(namespace));
    form.setDescription("Add a new product type to the inventory.");
    form.addTextItem()
        .setTitle("Product name")
        .setRequired(true);
    form.addTextItem()
        .setTitle("How many are in stock now?")
        .setValidation(mustBeANonNegativeNumber);
    form.addTextItem()
        .setTitle("How many do you want to keep in stock at all times?")
        .setValidation(mustBeANonNegativeNumber);
    return form;
}
function _onNewProductTypeFormSubmit(event){
    const row = event.values;
    row.shift(); // remove first cell (timestamp)
    const name = row[0];
    const quantity = parseInt(row[1]);
    const minimum = parseInt(row[2]);
    const product = new ProductType(
        name,
        (isNaN(quantity)) ? undefined : quantity,
        (isNaN(minimum)) ? undefined : minimum
    );
    console.log("New product: " + JSON.stringify(product));
    createProductService().handleNewProduct(product);
    createSettings().setStockUpdateFormStale(true);
}
// glob of settingSheet
/**
 * This module is responsible for the settings sheet created by the application
 */
function settingSheetModule(workbook, namespace){
    return new Component(
        workbook,
        namespace,
        _settingSheetNameFor,
        (ns)=>_setupSettingSheet(workbook, ns)
    );
}
function _settingSheetNameFor(namespace=""){
    return nameFor("settings", namespace);
}
function _setupSettingSheet(workbook, ns){
    const sheet = workbook.insertSheet(_settingSheetNameFor(ns));
    sheet.setFrozenRows(1);
    const headers = ["name", "value", "description"];
    sheet.appendRow(headers);
    const service = createSettings(workbook, ns);
    service.populateDefaults();
    service.setWorkbook(workbook);
}
function createSettings(workbook=null, namespace=""){
    if(workbook === null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    const sheet = workbook.getSheetByName(_settingSheetNameFor(namespace));
    const repo = _makeGoogleSheetsSettingRepository(sheet);
    const service = new Settings(
        (name) => repo.getEntityByKey(name),
        (k, v) => {
            const old = repo.getEntityByKey(k);
            const updated = new Setting(k, v, old.description);
            repo.update(updated);
        },
        (setting)=>repo.addEntity(setting)
    )
    return service;
}
function _makeGoogleSheetsSettingRepository(sheet){
    return new GoogleSheetsRepository(
        sheet,
        setting => setting.name,
        setting => [setting.name, setting.value, setting.description],
        row => new Setting(row[0], row[1], row[2])
    );
}
// glob of stockUpdateForm
/**
 * This module is responsible for the Google Form used to update the quantity of
 * each product currently in the inventory.
 */
/**
 * Use this to interface with the "Stock Update" form component of the system.
 * @param {SpreadsheetApp.Spreadsheet|null} workbook
 * @param {string|undefined} namespace
 * @returns the "Stock Update" form component of the application
 */
function stockUpdateFormModule(workbook=null, namespace=""){
    if(workbook === null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    return new Component(
        workbook,
        namespace,
        _stockUpdateFormNameFor,
        (ns)=>{
            const form = _createNewStockUpdateForm(ns);
            createSettings(workbook, namespace).setStockUpdateForm(form);
            return form;
        },
        _onStockUpdateFormSubmit
    );
}
function _stockUpdateFormNameFor(namespace=""){
    return nameFor("Stock Update", namespace);
}
function _createNewStockUpdateForm(namespace=""){
    const form = FormApp.create(_stockUpdateFormNameFor(namespace));
    form.setDescription("How many of each of these are in stock now?");
    _populateStockUpdateForm(form, namespace);
    return form;
}
function _populateStockUpdateForm(form, namespace){
    const mustBeANonNegativeNumber = FormApp.createTextValidation()
        .setHelpText("Must be a non-negative number.")
        .requireNumberGreaterThanOrEqualTo(0)
        .build();
    const service = createProductService(namespace);
    const productNames = service.getAllEntities().map(pt => pt.name);
    productNames.forEach(productName => {
        form.addTextItem()
            .setTitle(productName)
            .setRequired(false)
            .setValidation(mustBeANonNegativeNumber);
    });
}
function _onStockUpdateFormSubmit(e){
    /*
    e.namedValues is formatted as
    {
        foo: ["answer to foo"],
        bar: ["answer to bar"]
    }
    From what I gather, the last value of the foo array is the response to foo.
    Previous indices are in case multiple questions have existed with the same
    name. These arrays will get longer each time the form regenerates.
    */
    const fields = [];
    for(let [k, v] of Object.entries(e.namedValues)){
        //                                       last item
        fields.push({name: k, quantity: parseInt(v[v.length - 1])});
    }
    const products = fields.filter(answerToQuestion => {
        return !isNaN(answerToQuestion.quantity);
    }).filter(answerToQuestion => {
        return "Timestamp" !== answerToQuestion.name;
    }).map(answerToQuestion =>{
        return new ProductType(answerToQuestion.name, answerToQuestion.quantity);
    });
    console.log(JSON.stringify(products));
    createProductService().handleLogForm(products);
}
function regenerateStockUpdateFormFor(workbook, namespace=""){
    const name = _stockUpdateFormNameFor(namespace);
    const sheet = workbook.getSheetByName(name);
    if(sheet === null){ // stock update form has not yet been generated
        stockUpdateFormModule(workbook, namespace).setup();
    } else {
        // remove all items, repopulate
        const formUrl = sheet.getFormUrl();
        const oldForm = FormApp.openByUrl(formUrl);
        oldForm.getItems().forEach(item=>oldForm.deleteItem(item));
        _populateStockUpdateForm(oldForm, namespace);
    }
    createSettings(workbook, namespace).setStockUpdateFormStale(false);
}
// glob of userForm
/**
 * This module is responsible for the Google Form used to add new users to the
 * user sheet.
 */
function userFormModule(workbook=null, namespace=""){
    if(workbook === null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    return new Component(
        workbook,
        namespace,
        _userFormNameFor,
        (ns)=>{
            const form = _createUserForm(ns);
            createSettings(workbook, namespace).setUserForm(form);
            return form;
        },
        _onUserFormSubmit
    );
}
function _userFormNameFor(namespace){
    return nameFor("user form", namespace);
}
function _createUserForm(namespace){
    const mustBeEmail = FormApp.createTextValidation()
        .setHelpText("Must be an email address")
        .requireTextIsEmail()
        .build();
    const form = FormApp.create(_userFormNameFor(namespace));
    form.setDescription("Sign up to receive the Stock Update or Log email.");
    form.addTextItem()
        .setTitle("Email")
        .setValidation(mustBeEmail)
        .setRequired(true);
    const stock = form.addMultipleChoiceItem();
    stock.setTitle("Would you like to receive a copy of the Stock Update form?")
        .setChoices([
            stock.createChoice("No"),
            stock.createChoice("Yes")
        ]);
    const log = form.addMultipleChoiceItem();
    log.setTitle("Would you like to receive a copy of the Log report email?")
        .setChoices([
            log.createChoice("No"),
            log.createChoice("Yes")
        ]);
    return form;
}
function _onUserFormSubmit(e){
    const row = e.values;
    row.shift(); // get rid of timestamp
    /*
    this still overrides previous user if row[1] or row[2] is empty, setting it
    to false. Asking client expected behavior.
    */
    const email = row[0];
    const wantsLog = row[1] === "Yes";
    const wantsReport = row[2] === "Yes";
    const user = new User(email, wantsLog, wantsReport);
    console.log("New user: " + JSON.stringify(user));
    createUserService().handleUserForm(user);
}
// glob of userSheet
/**
 * This module is responsible for the user sheet created by the application in
 * its host Google Spreadsheet
 */
function userSheetModule(workbook, namespace){
    return new Component(
        workbook,
        namespace,
        _userSheetNameFor,
        (ns)=>_setupUserSheet(workbook, ns)
    );
}
function _setupUserSheet(workbook, namespace){
    const userSheet = workbook.insertSheet(_userSheetNameFor(namespace));
    userSheet.setFrozenRows(1);
    const headers = ["email", "wants log", "wants report"];
    userSheet.appendRow(headers);
    const mustBeEmail = SpreadsheetApp.newDataValidation()
        .requireTextIsEmail()
        .setAllowInvalid(false)
        .setHelpText("must be a valid email address")
        .build();
    const emailCol = userSheet.getRange("A2:A");
    emailCol.setDataValidation(mustBeEmail);
    const mustBeYesOrNo = SpreadsheetApp.newDataValidation()
        .requireValueInList(["yes", "no"])
        .setAllowInvalid(false)
        .setHelpText("must be either 'yes' or 'no', without quote marks")
        .build();
    const boolCols = userSheet.getRange("B2:C");
    boolCols.setDataValidation(mustBeYesOrNo);
}
function _userSheetNameFor(namespace=""){
    return nameFor("users", namespace);
}
/**
 * Use this to access the UserService
 * @param {undefined|SpreadsheetApp.Spreadsheet} workbook
 * @param {undefined|string} namespace
 * @return {UserService} a UserService for interacting with this workbook
 */
function createUserService(workbook=null, namespace=""){
    if(workbook === null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    const sheet = workbook.getSheetByName(_userSheetNameFor(namespace));
    const repo = _makeGoogleSheetsUserRepository(sheet);
    const service = new UserService(repo);
    return service;
}
function _makeGoogleSheetsUserRepository(sheet){
    return new GoogleSheetsRepository(
        sheet,
        (user)=>user.email,
        (user)=>[
            user.email,
            (user.wantsLog) ? "yes" : "no",
            (user.wantsReport) ? "yes" : "no"
        ],
        (row)=>new User(
            row[0],
            row[1] === "yes", // empty cells count as "no"
            row[2] === "yes"
        )
    );
}
// glob of workspace
/**
 * This module is responsible for integrating with Google Workspace. By doing so
 * in a separate file from the bulk of the system, third-party dependencies are
 * isolated from the core system, allowing it to more easily port between
 * implementations.
 *
 * About NAMESPACES:
 *  since some of the project's tests must interact with Google sheets, there
 *  must be some way of preventing those tests from modifying the sheets used
 *  by the application. To do this, NAMESPACES can be included in a sheet name
 *  to designate who they belong to. This is done through the nameFor function:
 *      nameFor(resourceName, namespace)
 */
const FORM_HANDLER_NAME = onFormSubmit.name;
/*
this does not automatically start handling forms, and is explicitly registered
in _setupFormHandler
*/
function onFormSubmit(e){
    console.log("Received form submission: \n" + JSON.stringify(e));
    /*
    ugly duck-typing, but it looks like e doesn't have any other way of knowing
    which form submitted it
    */
    if("Product name" in e.namedValues){
        newProductTypeFormModule().receiveForm(e);
    } else if("Email" in e.namedValues){
        userFormModule().receiveForm(e);
    } else {
        stockUpdateFormModule().receiveForm(e);
    }
}
/*
Circumvents the Google script inheritance issue caused by unpredictable
script execution order. Also note that inheritance does not work as expected
even when used in the same file as the superclass.
*/
class Component {
    /**
     * @param {SpreadsheetApp.Spreadsheet} workbook
     * @param {string} namespace
     * @param {(string)=>string} namespaceToName
     * @param {(string)=>Form|null|undefined} create
     * @param {(FormEvent)=>void} onSubmit
     */
    constructor(workbook, namespace, namespaceToName, create, onSubmit){
        this.workbook = workbook;
        this.namespace = namespace;
        this.name = namespaceToName(namespace);
        this.create = create;
        this.onSubmit = onSubmit;
    }
    setup(){
        // does not bind 'this' context with just "this._doSetup"
        ifSheetDoesNotExist(this.workbook, this.name, ()=>this._doSetup());
    }
    _doSetup(){
        const formOrMaybeNot = this.create(this.namespace); // NOT this.name
        if(formOrMaybeNot && formOrMaybeNot.setDestination){
            this._doSetupForm(formOrMaybeNot);
        }
    }
    _doSetupForm(form){
        form.setDestination(
            FormApp.DestinationType.SPREADSHEET,
            this.workbook.getId()
        );
        /*
        The form is created using the Google Forms service instead of the Sheets
        service, so the call to setDestination does not alter workbook. Sheets
        caches the contents of the spreadsheet when it is accessed using
        SpreadsheetApp, and the contents are only updated when a writing
        function is used. Since getSheets is a reading call, it reads the cached
        list of sheets, which excludes the newly created destination sheet.
        https://issuetracker.google.com/issues/36764101
        */
        SpreadsheetApp.flush(); // updates the workbook variable
        // rename the sheet created by setDestination so it's easier to find
        // this URL solution doesn't work: https://stackoverflow.com/a/51484165
        const formId = form.getId();
        const createdSheet = this.workbook.getSheets().filter(sheet => {
            return null !== sheet.getFormUrl();
        }).find(sheet => {
            const form = FormApp.openByUrl(sheet.getFormUrl());
            return form.getId() === formId;
        });
        createdSheet.setName(this.name);
        createdSheet.hideSheet();
    }
    delete(){
        deleteSheet(this.workbook, this.name);
    }
    receiveForm(event){
        this.onSubmit(event);
    }
}
function allModulesFor(workbook=null, namespace=""){
    if(workbook === null){
        workbook = SpreadsheetApp.getActiveSpreadsheet();
    }
    return [
        settingSheetModule(workbook, namespace), // must be first
        inventorySheetModule(workbook, namespace),
        userSheetModule(workbook, namespace),
        userFormModule(workbook, namespace),
        newProductTypeFormModule(workbook, namespace),
        stockUpdateFormModule(workbook, namespace)
    ];
}
/**
 * Mutates the given workbook into a suitable environment for the application.
 * @param {SpreadsheetApp.Spreadsheet} workbook
 * @param {string|undefined} namespace - can specify for testing
 */
function setupWorkspace(workbook, namespace=""){
    allModulesFor(workbook, namespace).forEach(m=>m.setup());
    _setupFormHandler(workbook);
}
function _setupFormHandler(workbook){
    const triggers = ScriptApp.getProjectTriggers();
    const formSubmitTrigger = triggers.find(t => t.getHandlerFunction() === FORM_HANDLER_NAME);
    if(!formSubmitTrigger){
        ScriptApp.newTrigger(FORM_HANDLER_NAME)
            .forSpreadsheet(workbook)
            .onFormSubmit()
            .create();
    }
}
function deleteWorkspace(workbook, namespace=""){
    allModulesFor(workbook, namespace).forEach(m=>m.delete());
    if("" === namespace){
        const triggers = ScriptApp.getProjectTriggers();
        const formSubmitTrigger = triggers.find(t => {
            return t.getHandlerFunction() === FORM_HANDLER_NAME;
        });
        if(formSubmitTrigger !== null){
            ScriptApp.deleteTrigger(formSubmitTrigger);
        }
    }
}
/**
 * Deletes a sheet and any attached formsfrom the workbook if the sheet exists.
 * @param {SpreadsheetApp.Spreadsheet} workbook
 * @param {string} sheetName
 */
function deleteSheet(workbook, sheetName){
    const sheet = workbook.getSheetByName(sheetName);
    if(sheet !== null){
        const formUrl = sheet.getFormUrl();
        if(formUrl !== null){
            // delete attached form
            const form = FormApp.openByUrl(formUrl);
            form.removeDestination();
            const file = DriveApp.getFileById(form.getId());
            file.setTrashed(true);
        }
        workbook.deleteSheet(sheet);
    }
}
/**
 * @param {SpreadsheetApp.Spreadsheet} workbook
 * @param {string} sheetName
 * @param {void function(string)} doThis
 */
function ifSheetDoesNotExist(workbook, sheetName, doThis){
    if(null === workbook.getSheetByName(sheetName)){
        doThis(sheetName);
    }
}
/**
 * Each workbook should support multiple namespaces for testing purposes, though
 * should also support a default, unspecified namespace
 * @param {string} resource - sheet or form name
 * @param {string|undefined} namespace
 * @returns the name for the given sheet within the given namespace
 */
function nameFor(resource, namespace=""){
    mustHaveValue(resource);
    mustHaveValue(namespace);
    return ("" === namespace) ? resource : `${namespace}-${resource}`;
}
/*
Unit tests
*/
function testWorkspaceModule(){
    const workbook = SpreadsheetApp.getActiveSpreadsheet();
    deleteWorkspace(workbook, "test");
    setupWorkspace(workbook, "test");
    testNameFor();
    testEmailModule();
    testGoogleSheetsProductTypeRepository(workbook);
    /*
    only remove test sheets if tests are successful, as this allows us to
    diagnose errors if one of these tests fails
    */
    deleteWorkspace(workbook, "test");
}
function testNameFor(){
    const sheetName = "foo";
    const namespace = "bar";
    const sheetWithoutNamespace = nameFor(sheetName);
    assert(sheetWithoutNamespace.includes(sheetName));
    const sheetWithNamespace = nameFor(sheetName, namespace);
    assert(sheetWithNamespace.includes(sheetName));
    assert(sheetWithNamespace.includes(namespace));
}
